# 🎁 Chapter 06. 메시지와 인터페이스
- 객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것
- 하지만 클래스는 도구에 불과
- 애플리케이션은 클래스의 집합으로 구성되는 것이 아닌 메시지를 통해 정의됨
- 객체지향 애플리케이션의 가장 중요한 재료는 객체들이 주고받는 메시지 즉, 객체가 수행하는 책임

## 🥑 01. 협력과 메시지
### 🍞 메시지와 메시지 전송
#### 메시지
메시지(message)는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단.
- 메시지 전송(message sending) or 메시지 패싱(message passing): 한 객체가 다른 객체에게 도움을 요청하는 것
    - 이때 메시지를 전송하는 객체 = 메시지 전송자(message sender)
    - 메시지를 수신하는 객체 = 메시지 수신자(message receiver)
- 메시지는 오퍼레이션명(operation name)과 인자(argument)로 구성
    - 메시지 전송은 여기에 메시지 수신자를 추가한 것
    - 따라서 **메시지 전송**은 메시지 수신자, 오퍼레이션명, 인자의 조합

### 🍞 퍼블릭 인터페이스와 오퍼레이션
- 객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다.
    - 외부에서 볼 때 객체의 안쪽은 검은 장막으로 가려진 미지의 영역
    - 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있음
    - 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 ```퍼블릭 인터페이스```라고 부른다.
- 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 ```오퍼레이션(operation)```이라고 부른다.
    - 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화

#### 👀 UML에서 정의하는 오퍼레이션
- 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세다.
- 오퍼레이션은 구현이 아닌 추상화다.
    - 반면 UML의 메서드는 오퍼레이션을 구현한 것
    - 인용하면, 메서드는 오퍼레이션에 대한 구현
- 메서드는 오퍼레이션과 연관된 알고리즘 또는 절차를 명시한다.

### 🍞 시그니처
- 오퍼레이션의 이름과 파라미터 목록을 합쳐 ```시그니처(signature)```라고 부른다.
- 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것
- 메서드는 이 시그니처에 구현을 더한 것

## 🥑 02. 인터페이스와 설계 품질
- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 함
    - 최소한의 인터페이스: 꼭 필요한 오퍼레이션만을 인터페이스에 포함
    - 추상적인 인터페이스 : 어떻게 수행하는지가 아닌 무엇을 하는지를 표시
- 책임 주도 설계를 통해 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지함

### 🍞 디미터 법칙(Law of Demeter)
- 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.
- 낯선 자에게 말하지 말라
- 오직 인접한 이웃하고만 말하라
</br>

디미터 법칙을 따르기 위해서는 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 해야 함.
- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

캡슐화의 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.

#### 👀 부끄럼타는 코드 (shy code)
- 불 필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드
    - 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.
    - 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.

#### 👀 기차 충돌 (train wreck)
```Java
// 디미터 법칙을 위반하는 코드
screening.getMovie().getDiscountConditions();
```

수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다.
- 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송하고 있음
- 이와 같은 코드 = ```기차 충돌(train wreck)```

```Java
// 수정된 코드
screening.calculateFee(audienceCount)
```

## 🥑 03. 원칙의 함정
- 디미터 법칙과 묻지 말고 시켜라는 훌륭한 설계 원칙이지만 절대적인 법칙은 아니다.
- 설계가 트레이드오프의 산물이라는 것을 잊지 말 것.
- 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라. 
    - 원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것.

### 🍞 명령-쿼리 분리 원칙(Command-Query Separation)
퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공함

- ```루틴(routine)```: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
- ```루틴(routine)``` = ```프로시저(procedure)``` + ```함수(function)```
    - 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없음
    - 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없음
- ```명령(Command)```: 객체의 상태를 수정하는 오퍼레이션
- ```쿼리(Query)``` : 객체와 관련된 정보를 반환하는 오퍼레이션
    - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
    - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

### 🍞 명령-쿼리 분리와 참조 투명성
- 명령과 쿼리를 엄격하게 분류하면 객체의 부수효과를 제어하기가 수월해짐
- 쿼리는 객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관없음
- 명령이 개입하지 않는 한 쿼리의 값은 변경되지 않기 때문에 쿼리의 결과를 예측하기 쉬워짐
- 또한 쿼리들의 순서를 자유롭게 변경할 수 있음