# 부록 A. 계약에 의한 설계

인터페이스만으로 객체의 행동에 관한 다양한 관점을 전달하기 어렵다. 따라서 명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단인 **계약에 의한 설계**가 주는 혜택으로 눈을 돌려야 한다.

## 01. 협력과 계약

### 부수효과를 명시적으로

프로그래밍 언어의 인터페이스는 메시지의 이름과 파라미터 목록은 시그니처를 통해 전달할 수 있지만 객체 사이의 협력을 위해 필요한 약속과 제약은 전달할 수 없다. 작가는 해당 부분을 보완하기 위해 `C#`의 라이브러리인 `CodeContracts`를 사용하는 코드를 보여주며 전달한다.

해당 코드에선 `IsSatisfied`메서드의 반환값이 `true`일 경우에만 `Reschedule` 메서드를 호출할 수 있다는 사실을 명확하게 표현한다. 이렇게 작성된 계약(Contracts)은 문서화로 끝나는 것이 아니라 졔약 조건의 만족 여부를 실행 중에 체크할 수 있다. 다른 장점으로는 이 조건들을 코드로부터 추출해서 문서를 만들어주는 자동화 도구도 제공한다는 것이다.

### 계약

계약의 세부적인 내용은 상황에 따라 다르지만 일반적으로 다음과 같은 특성을 가진다.

- 각 계약 당사자는 계약으로부터 **이익**을 기대하고 이익을 얻기 위해 의무를 이행한다.
- 각 계약 당사자의 이익과 의무는 계약서에 **문서화**된다.

이처럼 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어다.

## 02. 계약에 의한 설계

버트란드 마이어가 사람들 사이의 계약에 착안해 계약에 의한 설계 기법을 고안했다.

- 협력에 참여하는 각 객체는 계약으로부터 이익을 기대하고 이익을 얻기 위해 **의무**를 이행한다.
- 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스상에 **문서화**된다.

계약에 의한 설계 개념은 "인터페이스에 대해 프로그래밍하라"는 원칙을 확장한 것이다. 계약에 의한 설계를 이용하면 오퍼레이션의 시그니처를 구성하는 다양한 요소들을 이용해 협력에 참여하는 객체들이 지켜야 하는 제약 조건을 명시할 수 있다.

- 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대한다.
- 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상한다.
- 클라이언트는 메시지 전송 전과 후의 서버의 상태가 정상일 것이라고 기대한다.

이 세 가지 기대가 바로 계약에 의한 설계를 구성하는 세 가지 요소에 대응된다.

- 사전조건: 메서드가 호출되기 위해 만족돼야 하는 조건. 메서드의 요구사항을 명시한다. 사전조건이 만족되지 않을 경우 메서드가 실행돼서는 안 된다. 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무다.
- 사후조건: 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건. 클라이언트가 사전조건을 만족시켰다면 메서드는 사후조건에 명시된 조건을 만족시켜야 한다. 만약 클라이언트가 사전조건을 만족시켰는데도 사후조건을 만족시키지 못한 경우에는 클라이언트에게 예외를 던져야 한다.
- 불변식: 항상 참이라고 보장되는 서버의 조건. 메서드가 실행되는 도중에는 불변식을 만족시키지 못할 수도 있지만 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이어야 한다.

### 사전조건

일반적으로 사전조건은 메서드에 전달된 인자의 정합성을 체크하기 위해 사용된다. 조건을 메서드의 사전조건으로 정의함으로써 메서드가 잘못된 값을 기반으로 실행되는 것을 방지할 수 있다. 이렇게 잘못된 값을 기반으로 실행되는 것을 방지할 수 있다.

### 사후조건

일반적으로 사후조건은 다음과 같은 세 가지 용도로 사용된다.

- 인스턴스 변수의 상태가 올바른지 서술하기 위해
- 메서드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해
- 반환값이 올바른지를 서술하기 위해

다음과 같은 두 가지 이유로 인해 사전조건보다 사후조건을 정의하는 것이 더 어려울 수 있다.

- 한 메서드 안에서 return 문이 여러 번 나올 경우
  - 모든 return 문마다 결괏값이 올바른지 검증하는 코드를 추가해야 한다. 다행히도 계약에 의한 설계를 지원하는 대부분의 라이브러리는 결괏값에 대한 사후조건을 한 번만 기술할 수 있게 해준다.
- 실행 전과 실행 후의 값을 비교해야 하는 경우
  - 실행 전의 값이 메서드 실행으로 인해 다른 값으로 변경됐을 수 있기 때문에 두 값을 비교하기 어려울 수 있다. 다행히 계약에 의한 설계를 지원하는 대부분의 라이브러리는 실행 전의 값에 접근할 수 있는 간편한 방법을 제공한다.

> 이후 Code Contracts에 대한 내용은 생략.

### 불변식

불변식은 다음과 같은 두 가지 특성을 가진다.

- 클래스의 모든 인스턴스가 생성된 후에 만족돼야 한다.
  - 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다는 것을 의미한다.
- 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수돼야 한다.
  - 메서드가 실행중일 때 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요는 없지만 메서드 실행 전과 메서드 종료 후에는 항상 불변식을 만족하는 상태가 유지돼야 한다.

불변식은 클래스의 모든 메서드의 사전조건과 사후조건에 추가되는 공통의 조건으로 생각할 수 있다. 메서드가 실행되기 전에 사전조건과 함께 실행되며, 메서드가 실행된 후에 사후조건과 함께 실행된다. 만약 불변식을 수작업으로 작성한다면 모든 메서드에 동일한 불변식을 추가해야 할 것이다.

> 이후 Code Contracts에 대한 내용은 생략.

## 03. 계약에 의한 설계와 서브타이핑

> 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.

리스코프 치환 원칙의 규칙을 두 가지 종류로 세분화할 수 있다.

- 계약 규칙: 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙이다.

  - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
  - 서브타입에 더 완화된 사후조건을 정의할 수 없다.
  - 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.

- 가변성 규칙: 파라미터와 리턴 타입의 변형과 관련된 규칙이다.

  - 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.
  - 서브타입의 리턴 타입은 공변성을 가져야 한다.
  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다.

공변성: `A`가 `B`의 서브타입일 때, `T<A>`가 `T<B>`의 서브타입이 되는 경우
반공변성: `A`가 `B`의 서브타입일 때,`T<B>`가 `T<A>`의 서브타입이 되는 반대의 경우

저자는 계약에 의한 설계가 특정한 라이브러리나 프레임워크와 상관없는 설계 개념이라고 얘기하며, 언어 차원에서 적절한 라이브러리가 없다고 해도 계약에 의한 설계를 적용하는 것은 가능하다는 사실을 이해하게 될 것이라고 설명한다.

### 계약 규칙

핸드폰 과금 시스템에서의 예시가 나온다.
많은 `RatePolicy` 클래스들이 실제로 서브타입인가?(리스코프 치환 원칙을 만족하는가?)에 대해 이해를 돕기 위한 `publishBill` 메서드를 `Phone`에 추가하는 예시를 볼 수 있다.

- 요금 청구서를 발생하는 `publishBill` 메서드에서 `calculateFee`의 반환값은 최소한 0원보다 크거나 같아야 하므로 사후조건을 아래와 같이 정의한다.
  `assert result.isGreaterThanOrEqual(Money.ZERO);`

- calculateFee 오퍼레이션을 호출할 때 클라이언트인 Phone이 보장해야 하는 사전 조건은 파라미터인 calls가 null이 아니어야 한다. 따라서 다음과 같이 사전조건을 정의한다.
  `assert calls != null`

> 이후에도 RatePolicy 등 이후에 지정해야 할 사전, 사후조건에 대한 코드가 나오지만 생략하겠다.

### 가변성 규칙

**서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다.**

- `RatePolicy`의 `CalculateFee` 오퍼레이션이 빈 리스트를 전달받았을 때 `EmptyCallException` 예외를 던지도록 계약을 수정한다.
- 하지만 다른 예외 발생, `AdditionalRatePolicy` 클래스가 `NoneElementException`을 던진다고 가정한다.
- `NoneElementException` 클래스가 `EmptyCallException` 클래스의 자식 클래스라면 `AdditionalRatePolicy`는 `RatePolicy`를 대체할 수 있을 것이다.
- 하지만 상속 계층이 다르다면 하나의 catch 문으로 두 예외를 모두 처리할 수 없기 때문에 대체할 수 없게 된다.

`Bird`를 상속받는 `Penguin`이 `fly` 메서드에서 예외를 던지듯이 상속은 받았지만 `fly` 메서드의 실행을 막아야 했던 개발자의 예시가 있겠다.
계약을 위반하는 또 다른 예는 `fly` 메서드의 기능을 퇴화시키는 경우다. 상속을 받은 `Penguin`에서 `fly` 메서드를 아무것도 하지 않게 함으로써 응답은 하지만 기능 자체를 제거할 수 있다. 하지만 클라이언트 관점에서 `Bird`가 날 수 없는 것이기 때문에 올바르지 않다.

### 함수 타입과 서브타이핑

최근의 객체지향 언어들은 이름 없는 메서드를 정의할 수 있게 허용한다. 다양한 언어에서 다음과 같이 불린다.

- 익명 함수
- 함수 리터럴
- 람다 표현식 등..

이름 없이 메서드를 정의하는 것을 허용하는 언어들은 객체의 타입뿐만 아니라 메서드의 타입을 정의할 수 있게 허용한다. 그리고 타입에서 정의한 시그니처를 준수하는 메서드들을 이 타입의 인스턴스로 간주한다. 즉, 파라미터 타입과 리턴 타입이 동일하면 모두 같은 타입의 인스턴스이다.

### ✍🏻 Writer

|                                                                   이승철                                                                   |
| :----------------------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/83414134/202398444-a93994ce-6299-44a1-9c05-695abc618d1e.png" width="150" height="150"> |
|                                                   [Seung72](https://github.com/Seung72)                                                    |
