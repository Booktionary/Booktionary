# Ch07. 함께 모으기

> "코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다." - 에릭 에반스

마틴 파울러는 객체지향 설계 안에 존재하는 세 가지의 상호 연관된 관점에 대해 설명한다. 아래의 관점들은 해당 순서대로 개발하는 것이 아닌 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다.

- 개념 관점: 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다. 여기서 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제이고 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.
- 명세 관점: 도메인의 개념이 아닌 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞추는 것. 객체의 인터페이스에 초점을 둔 관점이다.
- 구현 관점: 실제 작업을 수행하는 코드와 연관돼 있다. 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다.

## 커피 전문점 도메인

### 커피 주문

> **예제** - 커피 제조하기<br>
> 이번에 다룰 도메인은 동네 어디서나 볼 수 있는 아담한 커피 전문점이다. 커피 전문점에서는 아메리카노, 카푸치노, 카라멜 마키아또, 에스프레소의 네 가지 커피를 판매하고 있다. 판매하는 커피도 몇 종류 되지 않고 내부도 그리 넓지 않지만 하늘색 페인트로 칠해진 벽과 코를 간지럽히는 고소한 커피 향이 어우러져 전체적으로 아늑하고 편안한 분위기를 풍긴다. 조촐한 가게 내부를 둘러보니 하얀색의 테이블들이 커피향으로 가득찬 공간을 채우듯 옹기종기 놓여져 있고, 그 위에는 커피의 이름과 가격이 적힌 작은 메뉴판이 비치돼 있다.

| 메뉴            | 가격    |
| --------------- | ------- |
| 아메리카노      | 1,500원 |
| 카푸치노        | 2,000원 |
| 카라멜 마키아또 | 2,500원 |
| 에스프레소      | 2,500원 |

> 손님이 테이블에 앉아 메뉴판을 잠시 훑어본 후 커피를 주문한다. 이제 주문받은 커피를 제조하는 것은 바리스타의 몫이다.
> 커피 전문점은 작고, 단순하고, 고려해야 할 사항도 거의 없는 아주 간단한 도메인이다. 우리의 최종 목표는 손님이 커피를 주문하는 사건을 컴퓨터에 재구성하는 것이다. 물론 객체를 이용해서 말이다.

### 커피 전문점이라는 세상

**커피 전문점을 객체들로 구성된 작은 세상으로 바라볼 때**
객체지향의 관점에서 메뉴판은 하나의 객체다. 네 개의 메뉴 항목 역시 객체로 볼 수 있다. 따라서 메뉴판은 네 개의 메뉴 항목 객체들을 포함하는 객체라고 볼 수 있다. 손님 역시 하나의 객체다. 손님 객체는 메뉴판 객체 안에 적힌 메뉴 항목 객체들 중에서 자신이 원하는 메뉴 항목 객체 하나를 선택해 바리스타 객체에게 전달할 것이다.
종합해 보면 객체지향의 관점에서 커피 전문점이라는 도메인은 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성된 작은 세상이다.
**객체들 간의 관계를 살펴볼 때**
손님은 메뉴판에서 주문할 커피를 선택할 수 있어야 한다. 따라서 손님은 어떤 식으로든 메뉴판을 알아야 하며, 이것은 두 객체 사이에 관계가 존재한다는 것을 암시한다. 손님은 바리스타에게 주문해야 하므로 손님과 바리스타 사이에도 관계가 존재한다. 바리스타는 커피를 제조하는 사람이므로 당연히 자신이 만든 커피와 관계를 맺는다.<br>
**객체를 정적인 타입으로 추상화하여 복잡성을 낮추기**

- 손님 객체: '손님 타입'의 인스턴스
- 바리스타 객체: '바리스타 타입'의 인스턴스
- 커피 객체: '커피 타입'의 인스턴스 또는 '메뉴 항목 타입'의 인스턴스로 모델링 가능
- 메뉴판 객체: 네 개의 메뉴 항목 객체를 포함한 '메뉴판 타입'의 인스턴스

**타입 간의 관계 존재**

<img src="https://user-images.githubusercontent.com/79628706/208682959-8064cc8a-cc61-4f8c-a5e1-b9ed33f56c78.png" width="250px"/>

- 속이 찬 마름모: **포함(cotainment)** 관계 또는 **합성(composition)** 관계를 나타낸 것
- 숫자 4: 메뉴판에 포함되는 메뉴 항목이 4개라는 것을 의미한다.
- 단순한 선: 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 할 경우, **연관(association)** 관계라고 한다.
  위 그림은 커피 제조와 관련된 객체들을 타입과 관계를 이용해 추상화한 일종의 모델이다. 이처럼 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 **도메인 모델** 이라고 한다.

## 설계하고 구현하기

### 커피를 주문하기 위한 협력 찾기

다시 한번 저자는 정리한다.
객체지향 설계의 첫 번째 목표는 훌륭한 객체를 설계하는 것이 아닌 훌륭한 협력을 설계하는 점, 훌륭한 객체는 훌륭한 협력을 설계할 때만 얻을 수 있다. 협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다. 메시지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다는 것을 의미한다. 메시지를 수신할 객체는 메시지를 처리할 책임을 맡게 되고 객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.
현재 설계하고 있는 협력은 커피를 주문하는 것이다. 아마도 첫 번째 메시지는 '커피를 주문하라'일 것이다.
<img src="https://user-images.githubusercontent.com/79628706/208683332-9279873c-552a-4c3b-9388-f06ee0166861.png" width="350px"/>

- 메시지 위에 붙은 화살표는 메시지에 담아 전달될 부가적인 정보인 인자를 의미한다.
  - '아메리카노를 주문하라' 메시지는 나중에 '커피를 주문하라(아메리카노)'와 같이 인자를 포함하는 형식으로 구현
- '커피를 주문하라'라는 메시지를 수신할 객체(주문할 책임을 지는 객체)는 손님 타입의 인스턴스이다.
- 손님이 커피 주문 중 스스로 할 수 없는 일은 다른 객체에게 요청해야 한다.
  - 손님은 메뉴 항목에 대해서 알지 못한다.
  - 메뉴 항목은 고객의 일부가 아니라 메뉴판의 일부이다.
  - 따라서 고객은 자신이 선택한 메뉴 항목을 누군가가 제공해 줄 것을 요청한다. '메뉴 항목을 찾아라'라는 새로운 메시지의 등장이다.
  - 아래의 작은 화살표는 이 메시지를 수신한 객체가 손님에게 무엇을 응답해야 하는지를 나타낸다.
  - '메뉴 이름'에 대응되는 '메뉴 항목'을 반환해야 한다.
  - 메뉴판 객체는 메뉴 항목 객체를 포함하고 있기 때문에 이 책임을 처리할 수 있는 가장 적절한 후보다.
- 손님은 메뉴 항목에 맞는 커피를 제조해달라고 요청할 수 있다.
  - 손님은 커피를 제조하는 메시지의 인자로 메뉴 항목을 전달하고 반환 값으로 제조된 커피를 받아야 한다.
- 바리스타는 커피 제조의 모든 정보를 알고 있다.
  - 아메리카노를 만들기 위한 지식은 바리스타의 상태로, 기술은 바리스타의 행동으로 간주할 수 있다.
  - 이런 관점에서 바리스타는 스스로의 판단과 지식에 따라 행동하는 자율적인 존재다.
- 커피 주문을 위한 협력은 이제 바리스타가 새로운 커피를 만드는 것으로 끝난다.

협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 대략적인 윤곽이 잡혔고, 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제하는 것이 남았다.

### 인터페이스 정리하기

각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다. 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안의 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.

- 손님 객체의 인터페이스 안에는 '커피를 주문하라'라는 오퍼레이션이 포함돼야 한다.
- 메뉴판 객체의 인터페이스는 '메뉴 항목을 찾아라'라는 오퍼레이션을 제공한다.
- 바리스타 객체의 인터페이스는 '커피를 제조하라'는 오퍼레이션을 제공한다.
- 커피 객체는 '생성하라'라는 오퍼레이션을 제공한다.

객체의 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것. 협력을 통해 식별된 타입의 오퍼레이션은 외부에서 접근 가능한 공용 인터페이스의 일부라는 사실을 기억해야 한다. 따라서 인터페이스에 포함된 오퍼레이션 역시 외부에서 접근 가능하도록 공용(public)으로 선언돼 있어야 한다.

```JAVA
class Customer {
    public void order(String menuName) {}
}
class MenuItem {
}
class Menu {
    public MenuItem choose(String name) {}
}
class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {}
}
class Coffee {
    public Coffee(MenuItem menuItem) {}
}
```

### 구현하기

클래스의 인터페이스를 식별했으므로 오퍼레이션을 수행하는 방법을 메서드로 구현하자.

- `Customer`의 협력: `Customer`는 `Menu`에게 `menuName`에 해당하는 `MenuItem`을 찾아달라고 요청해야 한다. 그리고 `MenuItem`을 받아 이를 `Barista`에게 전달하여 원하는 커피를 제조하도록 요청해야 한다.
- 문제는 `Customer`가 어떻게 `Menu`객체와 `Barista`객체에 접근할 것이냐다.
- 객체가 다른 객체에게 메시지를 전송하기 위해 먼저 객체에 대한 참조를 얻어야 한다.
- 따라서 `Customer`객체는 어떤 방법으로든 자신과 협력하는 `Menu`객체와 `Barista`객체에 대한 참조를 알고 있어야 한다.

여기서는 `Customer`의 `order()`메서드의 인자로 `Menu`와 `Barista` 객체를 전달받는 방법으로 참조 문제를 해결하기로 한다.

```JAVA
class Customer {
    public void order(String menuName, Menu menu, Barista barista) {
        MenuItem menuItem = menu.choose(menuName);
        Coffee coffee = barista.makeCoffee(menuItem);
        ...
    }
}
```

`Menu`는 `menuName`에 해당하는 `MenuItem`을 찾아야 하는 책임이 있다. 이 책임을 수행하기 위해서는 `Menu`가 내부적으로 `MenuItem`을 관리하고 있어야 한다. `Menu`의 `choose()` 메서드는 `MenuItem`의 목록을 하나씩 검사해가면서 이름이 동일한 `MenuItem`을 찾아 반환한다.

```JAVA
class Menu {
    private List <MenuItem> items;

    public Menu(List<MenuItem> items) {
        this.items = items;
    }
    public MenuItem choose(String name) {
        for(MenuItem each : items) {
            if(each.getName().equals(name)) {
                return each;
            }
        }
        return null;
    }
}
```

`Barista`는 `MenuItem`을 이용해서 커피를 제조한다.

```JAVA
class Barista {
    public Coffee makeCoffee {
        (MenuItem menuItem);
        return coffee;
    }
}
```

`Coffee`는 자기 자신을 생성하기 위한 생성자를 제공한다. `Coffee`는 커피 이름과 가격을 속성으로 가지고 생성자 안에서 `MenuItem`에 요청을 보내 커피 이름과 가격을 얻은 후 `Coffee`의 속성에 저장한다.

```JAVA
class Coffee {
    private String name;
    private int price;

    public Coffee(MenuItem menuItem) {
        this.name = menuItem.getName();
        this.price = menuItem.cost();
    }
}
```

`MenuItem`은 `getName()`과 `cost()` 메시지에 응답할 수 있도록 메서드를 구현해야 한다.

```JAVA
public class MenuItem {
    private String name;
    private int price;

    public MenuItem(String name, int price) {
        this.name = name;
        this.price = price;
    }
    public int cost() {
        return price;
    }
    public String getName() {
        return name;
    }
}
```

다음은 커피 전문점 코드를 클래스 다이어그램으로 나타낸 것이다.

<img src="https://user-images.githubusercontent.com/79628706/208684304-2cfa06ef-5cdc-4300-a6b8-cda5835bdd80.png" />

## 코드와 세 가지 관점

### 코드는 세 가지 관점을 모두 제공해야 한다

앞에서 작성한 코드는 세 가지 관점에 대해 설명해 준다.

- 개념 관점으로 바라봤을 때 `Customer`, `Menu`, `MenuItem`, `Barista`, `Coffee` 클래스를 바라본다. 이 클래스들은 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다는 사실을 쉽게 알 수 있다. 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 관리하기 쉽고 유지보수성을 향상 시킬 수 있다.

- 명세 관점은 클래스의 인터페이스를 바라본다. 클래스의 `public` 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다. 공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분이다. 인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수밖에 없다. 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.

- 구현 관점은 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니다. 따라서 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안 된다. 메서드와 속성이 철저하게 클래스 내부로 캡슐화되어야 한다는 것을 의미한다.

위 세 가지 관점은 동일한 코드를 바라보는 서로 다른 관점이다. 훌륭한 객체지향 프로그래머는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있다.
세 가지 관점이 명확하게 드러날 수 있게 코드를 개선하라. 그것이 변경에 유연하게 대응할 수 있는 객체지향 코드를 작성하는 가장 빠른 길이다.

### 도메인 개념을 참조하는 이유

- 도메인 개념 안에서 적절한 객체를 선택하는 것은 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.
- 이것은 시스템의 유지보수성에 커다란 영향을 미친다.
- 소프트웨어는 항상 변하고 설계는 변경을 위해 존재한다.
- 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

### 인터페이스와 구현을 분리하라

**"인터페이스와 구현을 분리하라"**

- 명세 관점은 클래스의 안정적인 측면을 드러내야 한다.
- 구현 관점은 클래스의 불안정한 측면을 드러내야 한다.
- 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수밖에 없다.

프로그래머의 입장에서 가장 많이 접하게 되는 것은 코드이기 때문에 구현 관점을 빈번하게 사용하지만, 실제 훌륭한 설계는 명세 관점인 객체의 인터페이스다. 명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있다.
여기서 중요한 것은 클래스를 봤을 때 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다는 것이다. 캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해서도 안 되고, 인터페이스와 구현을 명확하게 분리하지 않고 흐릿하게 섞어놓아서도 안 된다. 결국 세 가지 관점 모두 클래스를 바라볼 수 있으려면 훌륭한 설계가 뒷받침되어야 한다.

### ✍🏻 Writer

|                                                                   이승철                                                                   |
| :----------------------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/83414134/202398444-a93994ce-6299-44a1-9c05-695abc618d1e.png" width="150" height="150"> |
|                                                   [Seung72](https://github.com/Seung72)                                                    |
