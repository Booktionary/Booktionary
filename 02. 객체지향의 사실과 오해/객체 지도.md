# Ch06. 역할, 책임, 협력

> _"유일하게 변하지 않는 것은 모든 것이 변한다는 사실뿐이다"._ - 헤라클레이토스

여행 중 다른 마을로 이동해야 하는데 길을 모른다면?
1. 지나가는 사람에게 마을까지 묻기
2. 지도에 표시된 길을 따라가는 방법

이 둘은 길을 찾는 과정과 난이도에서 확연히 차이 남

첫 번째 방법은 **'기능적이고 해결책 지향적인 접근법'**
길을 가르쳐 주는 사람은 다른 마을까지 가는 경로를 단계별로 상세히 설명해야 함

* 이 방법은 일반적이지도, 재상 가능하지도 않음
* 강이나 산과 같은 중요한 랜드마크가 없다면 경로 설명이 어렵고 설명만으로 경로 찾기가 쉽지 않음

두 번째 방법은 설 세계의 지형을 기반으로 만들어진 추상화된 모델.
* 길을 찾는 데 필요한 컨텍스트 정보가 함축돼 있음
* 첫 번째 방법보다 쉽고 간단함
* 필요한 모든 정보가 지도 안에 포함돼 있기 때문에 산이나 강과 같은 특정 랜드마크를 이용해 길을 설명할 필요가 없음

첫 번째 방법은 **'기능적이고 해결 방법 지향적인 접근법'** 이라면 두 번째 방법인 지도를 이용하는 방법은 **'구조적이고 문제 지향적인 접근법'**

_지도는 길을 찾는데 필요한 구체적인 기능이 아니라 길을 찾을 수 있는 '구조'를 제공_

* 사람들의 요구사항은 계속 변하기 때문에 모델이 제공해야 하는 기능 역시 지속적으로 변할 수밖에 없음
* 따라서 **기능을 중심으로 구조를 종속시키는 접근법**은 범용적이지 않고 재사용이 불가능하며 변경에 취약한 모델을 낳게 됨.
* 이와 달리 **안정적인 구조를 중심으로 기능을 종속시키는 접근법**은 범용적이고 재사용 가능하며 변경에 유연하게 대처할 수 있는 모델을 만듦

앞에서는 객체지향을 역할과 책임을 수행햐며 협력하는 자율적인 객체들의 공동체로 정의했음.
이번 장에서는 기능이 아니라 구조를 바탕으로 시스템을 분할하는 객체지향의 또 다른 측면에 관해 설명한다고 함.

## 기능 설계 vs 구조 설계
모든 소프트웨어 제품의 설계에는 두 가지 측면이 존재
1. **기능 측면의 설계**
2. **구조 측면의 설계**

소프트웨어가 사용자에게 가치 있는 이유 = 사용자가 필요로 하는 기능을 제공하기 때문

소프트웨어를 개발하는 초기 단계에서는 사용자가 무엇을 원하는지, 그리고 사용자가 원하는 것을 만족시키기 위해 시스템이 어떤 기능을 제공해야 하는지에 초점을 맞춰야 함

성공적인 소프트웨어들이 지닌 공통적인 특징은
* 훌륭한 기능을 제공하는 동시에 사용자가 원하는 새로운 기능을 빠르고 안정적으로 추가할 수 있다는 것
* 최종 사용자들이 소프트웨어의 내부 구조를 볼 수는 없지만 깔끔하고 단순하며 유지 보수하기 쉬운 설계는 **사용자의 변하는 요구사항을 반영할 수 있도록 쉽게 확장 가능한 소프트웨어를 창조할 수 있는 기반이 된다**는 것

훌륭한 개발자는 **사용자가 만족할 수 있는 훌륭한 기능을 제공하는 동시에 예측 불가능한 요구사항 변경에 유연하게 대처할 수 있는 안정적인 구조를 제공하는 능력을 갖춰야 함**

어제 약속했던 기능을 제공하는 동시에 내일 변경될지도 모르는 요구사항도 수용할 수 있는 코드들을 고민하면서 단순하고 유연한 설계를 창조하는 것은 공학이라기보다는 예술에 가까움

미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것

훌륭한 설계자는 미래에 구체적으로 어떤 변경이 발생할 것인지를 예측하지 않음
* 단지 언젠가는 변경이 발생할 것이며 아직까지는 그것이 무엇인지 모른다는 사실을 겸허하게 받아들임
* 좋은 설계는 나중에라도 변경할 수 있는 여지를 남겨 놓는 설계
* 설계를 하는 목적은 나중에 설계하는 것을 허용하는 것, 설계의 일차적인 목표는 변경에 소요되는 비용을 낮추는 것

## 두 가지 재료: 기능과 재료
객체지향 세계를 구축하기 위해서는 사용자에게 제공할 '기능'과 기능을 담은 안정적인 '구조'라는 재료가 준비돼 있어야 함
**기능**
사용자가 자신의 목표를 달성하기 위해 사용할 수 있는 시스템의 서비스
**구조**
시스템의 기능을 구현하기 위한 기반으로, 기능 변경을 수용할 수 있도록 안정적이어야 함

초점은 이 두 재료를 어디에서 구하느냐로 이동함.
객체지향 개발에 관한 과거의 다양한 경험과 연구로부터 사람들은 구조를 표현하기 위해 일관되게 적용할 수 있는 두 가지 기법을 발견함

* 구조는 **사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현함**
* 기능은 **사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현함**

## 안정적인 재료: 구조
### 도메인 모델
모든 소프트웨어는 사용자의 필요성을 충족시키기 위해 존재함

병원 = 환자의 지료  기록을 보관 및 분석을 위해 사용
은행 = 자산을 관리하고 보호하기 위해 소프트웨어를 사용

소프트웨어를 사용하는 사람들은 자신이 관심을 가지고 있는 특정한 분야의 문제를 해결하기 위해 소프트웨어를 사용함
사용자가 프로그램을 사용하는 대상 분야를 **도메인**이라고 함

* 도메인 모델에서 모델이란 **대상을 단순화해서 표현한 것**
* 모델은 **지식을 선택적으로 단순화하고 의식적으로 구조화한 형태**
* 모델은 복잡성의 바다에서 길을 잃지 않고 중요한 문제에 집중할 수 있도록 필요한 지식만 재구성한 것 (대상을 추상화하고 단순화한 것)
* **모델은 복잡성을 관리하기 위해 사용하는 기본적인 도구**
* 도메인 모델이란 **소프트웨어가 목적하는 영역을 주의 깊게 추상화한 것**

### 도메인의 모습을 담을 수 있는 객체지향
최종 제품은 사용자의 관점을 반영해야 한다는 것, 이것은 소프트웨어 개발에도 동일하게 적용할 수 있음
* 최종 코드는 사용자가 도메인을 바라보는 관점을 반영해야 함
* 이것은 곧 애플리케이션이 도메인 모델을 기반으로 설계돼야 한다는 것을 의미
* 도메인 모델은 **소프트웨어 개발과 관련된 관계자들이 도메인에 대해 생각하는 관점**
* 개발자가 시스템의 구조를 바라보는 관점인 동시에 **소프트웨어 안에 구현된 코드의 모습 그 자체이기 때문**
* 따라서 도메인 모델의 세 가지 측면을 모두 모델링 할 수 있는 유사한 모델링 패러다임을 사용할수록 소프트웨어 개발이 쉬워질 것
* 객체지향은 이런 요구사항을 가장 범용적으로 만족시킬 수 있는 **거의 유일한 모델링 패러다임**

### 표현적 차이
**❗️소프트웨어 객체는 현실 객체에 대한 추상화가 아님❗️**
* 소프트웨어 객체와 현실 객체 사이의 관계를 가장 효과적으로 표현할 수 있는 단어는 바로 은유
* 소프트웨어 객체는 현실 객체를 모방한 것이 아니라 은유를 기반으로 재창조한 것
* 따라서 소프트웨어 객체는 현실 객체가 갖지 못한 특성을 가질 수도 있고 현실 객체가 하지 못하는 행동을 할 수도 있음

비록 소프트웨어 객체가 현실 객체를 왜곡한다고 하더라도 소프트웨어 객체는 현실 객체의 특성을 토대로 구축된다.
이처럼 소프트웨어 객체와 현실  객체 사이의 의미적 거리를 가리켜 **표현적 차이** 또는 **의미적  차이** 라고 한다.
* 핵심은 **은유를 통해 현실 객체와 소프트웨어 객체 사이의 차이를 최대한 줄이는 것**
* 소프트웨어 객체는 그 대상이 현실적인지, 현실적이지 않은지에 상관없이 도메인 모델을 통해 표현되는 도메인 객체들을 은유해야 함
* 이것이 도메인 모델이 중요한 이유

도메인 모델을 기반으로 설계하고 구현하는 것은 사용자가 도메인을 바라보는 관점을  그대로 코드에 반영할 수 있게 한다. 결과적으로 표현적 차이는 줄어들 것이며, **사용자의 멘탈이 그대로 코드에 녹아 스며들게 될 것이라는 것.**

<img src="https://user-images.githubusercontent.com/83414134/206273150-c0c2a42d-fb05-4cf6-8ba1-ad0b7e3494f7.png" width="400">

표현적 차이가 중요한 이유는 소프트웨어를 이해하고 수정하기 쉽게 만들어주기 때문.
코드의 구조가 도메인의 구조를 반영하기 때문에 도메인을 이해하면 코드를 이해하기 훨씬 수월해짐.

### 불안정한 기능을 담는 안정적인 도메인 모델
도메인 모델을 기반으로 코드를 작성하는 두 번째 이유 : 도메인 모델이 제공하는 구조가 상대적으로 안정적이기 때문

도메인 모델의 핵심 : **사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것.**
도메인에 대한 사용자의 관점을 반영해야 하는 이유 : **사용자들이 누구보다도 도메인의 '본질적인' 측면을 가장 잘 이해하고 있기 때문**
결론 : 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어의 구조를 설계를 설계하면 **변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있음**