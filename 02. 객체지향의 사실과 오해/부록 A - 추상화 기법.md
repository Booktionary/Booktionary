# 부록A. 추상화 기법

## 추상화 기법

추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다. 다음은 사람들이 세계를 이해하는 데 사용하는 중요한 추상화 기법의 종류를 나타낸 것이다.

- **분류와 인스턴스화**: **분류**는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다. 분류의 역은 범주로부터 객체를 생성하는 **인스턴스화** 과정이다.
- **일반화와 특수화**: **일반화**는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 **특수화**라고 한다.
- **집합과 분해**: **집합**은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 집합의 반대 과정은 전체를 부분으로 분리하는 **분해**과정이다.

객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 것이다.

## 분류와 인스턴스화

### 개념과 범주

- 자동차: 도로 위를 달리는 작은 승용차부터 특수 목적의 차량들까지
- 나무: 길거리에 자라는 다양한 종류의 가로수들

위처럼 자동차와 나무는 색상, 크기, 외관이 전부 동일하지 않지만 공통되는 부분과 유사한 특성을 바탕으로 자동차와 나무라는 개념으로 분류한다.
객체를 분류하고 **범주**로 묶는 것은 특정 집합에 공통의 **개념**을 적용하는 것을 의미한다. 개념은 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.

객체들을 공통적인 특성을 기반으로 범주를 묶고 개념을 적용하는 것은 범주라는 정신적인 렌즈를 통해 세상을 바라보는 것과 유사하다.

세상에 존재하는 객체에 개념을 적용하는 과정을 **분류**라고 한다. 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.

서로 다른 상태를 가진 무수히 많은 자동차와 나무를 개별적으로 다루지 않고 범주로 묶음으로써 세상에 존재하는 복잡성을 낮출 수 있다. 사람들은 분류를 통해 개별 현상을 하나의 개념으로 다룬다. 이때

- '수많은 개별적인 현상들'을 **객체**라고 한다.
- '하나의 개념'을 **타입**이라고 한다.
- 분류는 객체를 타입과 연관시키는 것이다.
- 타입에 해당하는 객체를 생성하는 과정은 **인스턴스화** 또는 **예시**라고 한다.

객체지향의 세계에서 개념을 가리키는 표준 용어는 타입이다. 따라서 타입과 개념은 동의어이다. 이런 관점에서 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 **인스턴스**라고 한다.

### 타입

객체를 타입에 따라 분류하기 위해서 객체가 타입에 속하는 여부를 확인할 수 있어야 한다.
타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.

- 심볼: 타입을 가리키는 간략한 이름이나 명칭
- 내연: 타입의 완전한 정의, 내연의 의미를 이요해 객체가 타입에 속하는지 여부를 확인할 수 있다.
- 외연: 타입에 속하는 모든 객체들의 집합

### 외연과 집합

타입과 외연은 타입에 속하는 객체들의 집합으로 표현한다. 집합은 외연을 가리키는 또 다른 명칭이다. 객체들은 동시에 서로 다른 집합에 포함될 수도 있다.

- **단일 분류(single classification)**: 한 객체가 한 시점에 하나의 타입에만 속하는 것
- **다중 분류(multiple classification)**: 한 객체가 한 시점에 여러 타입에 속하는 것

대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 대부분의 언어에서 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다. 이 관점에서 다중 분류를 다중 상속과 혼동해서는 안된다.

객체를 특정한 타입으로 분류하면 해당 객체는 타입의 집합에 포함된다.

- **동적 분류(dynamic classification)**: 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
- **정적 분류(static classification)**: 객체가 자신의 타입을 변경할 수 없는 경우

다중 분류와 동적 분류는 서로 배타적인 개념이 아니다. 개념적인 관점에서 다중 분류와 동적 분류를 함께 적용하는 것이 실세계의 복잡성을 모델링하는 데 유용하다. 클래스 기반의 객체지향 언어에서 타입은 클래스를 이용해서 구현된다. 대부분의 언어는 객체의 타입을 변경할 수 없다. 따라서 대부분의 언어는 동적 분류를 구현할 방법을 제공하지 않는다.

다중 분류와 동적 분류는 개념적 관점에서 도메인을 분석하는 데는 유용하지만 객체지향 프로그래밍 언어의 제약으로 인해 구현으로 옮기기는 쉽지 않다. 저자의 경험에 따르면 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는게 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법이라고 한다.

### 클래스

객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다. 클래스는 타입을 구현하는 용도 외에도 코드를 재사용하는 용도로 사용되기도 한다. 클래스 외에도 인스턴스를 생성할 수 없는 추상 클래스나 인터페이스를 이용해 타입을 구현할 수도 있다.

대부분의 객체지향 프로그래밍 언어에서 동일한 범주에 속하는 객체는 동일한 클래스의 인스턴스여야 한다. 대부분의 객체지향 언어는 본질적인 속성은 표현할 수 있지만 우연적인 속성은 표현할 수 없다. 따라서 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야만 한다.

## 일반화와 특수화

### 범주의 계층

18세기 유럽, 계속 발견되는 수천 종류의 생물에 대해 당시 학자들은 분류 체계가 없어 연구에 어려움을 겪고 있었다. 이때 카를로스 린네는 _`자연의 체계(Systema Naturae)`_ 논문을 발표했다. 린네의 생물 분류 체계는 '계'라는 최상위 단계가 있는 중첩된 계층 구조였다. 그리고 언어에 따라 다르게 불리는 생물에 대한 표준 명칭을 정의하기 위해 모든 생물에 대해 속명과 종명을 혼합한 이름을 붙이는 이명법을 적용했다.

린네의 분류법에 따른 얼룩 고양이는 다음과 같이 분류할 수 있다.

> 계: 동물계(Animalia)
> 문: 척색동물문(Chordata)
> 강: 포유류강(Mallalia)
> 목: 육식동물목(Carnivora)
> 과: 고양이과(Felidae)
> 속: 고양이속(Felis)
> 종: 고양이종(Catus)

린네의 계층 구조는 좀 더 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치한다. 이때 상위 범주를 하위 범주의 일반화라고 하고, 하위 범주는 상위 범주에 대한 특수화라고 한다.

### 서브타입

- 어떤 타입이 다른 타입보다 일반적이라면 **슈퍼타입(supertype)**
- 어떤 타입이 다른 타입보다 좀 더 특수하다면 **서브타입(subtype)**
- 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화다.

일반화와 특수화의 계층 구조에서 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가속성을 가진다. 내연의 관점에서 슈퍼타입 정의가 서브타입 정의보다 더 일반적이라는 것을 의미한다.

서브타입은 슈퍼타입의 본질적 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들이 슈퍼타입의 속성을 공유한다는 것을 쉽게 예상할 수 있다. 이와 같이 일반화의 특징을 이요하면 부분적인 사실로 복잡한 사실에 대한 논리적인 추론이 가능해진다.

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서 타입의 내연과 관련된 '100% 규칙'과 타입의 외연과 관련된 'Is-a 규칙'을 준수해야 한다고 말한다. 두 타입이 위 두 규칙을 만족시키지 못할 경우 두 타입 간에 일반화 관계는 성립하지 않는다.

### 상속

프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속 사용하는 것. 그러나 모든 상속 관계가 일반화 관계는 아니다.
일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응해야 한다는 것이다.

- 구조적인 순응(structural conformance): 타입의 내연과 관련된 100% 규칙을 의미한다. 이는 서브타입이 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야한다. 따라서 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족 시킬 수 있다.
- 행위적인 순응(behavioral conformance): 타입의 행위에 관한 것이다. 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다.

두 순응 모두 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 **대체 가능성**을 의미한다.

상속의 또 다른 용도는 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것이다.

상속의 두 가지 용도

- 서브타이핑(subtyping): 서브클래스가 슈퍼클래스를 대체할 수 있는 경우
  - 설계의 유연성이 목표
  - **인터페이스 상속(interface inheritance)** 이라고도 함
  - 특정 기대 집합의 서브타입과 슈퍼타입간의 구조적 또는 행위적 순응 관계 의미
  - 대체 가능성 포함
- 서브클래싱(subclassing): 서브클래스가 슈퍼클래스를 대체할 수 없는 경우
  - 코드의 중복 제거와 재사용이 목적
  - **구현 상속(implementation inheritnace)** 이라고 함

상속 사실만으로 클래스 간의 관계가 서브타이핑인지 서브클래싱인지 여부를 결정할 수 없다. 서브타이핑의 전제조건은 대체 가능성이기 때문에 클라이언트 관점에서 실제로 어떻게 사용되고 있는지를 확인해야 한다. 가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 주의 깊게 사용하는 것은 코드를 유연하게 만들고 재사용성을 높이는 한 가지 방법이다.

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 가장 기본적인 방법은 클래스 간의 **위임(delegation)** 을 사용하는 것이다.

- 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다.
- 만약 부모 클래스에서도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다.
- 클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임될 때까지 계속된다.

## 집합과 분해

### 계층적인 복잡성

안정적인 형태의 부분으로부터 전체를 구죽하는 행위를 **집합**이라고 하고 집합과 반대로 전체를 부분으로 분할하는 행위를 **분해**라고 한다. 집합의 가치는 많은 수의 사물들의 형상을 하나의 단위로 다룸으로써 복잡성을 줄일 수 있다. 즉 불필요한 세부 사항을 추상화한다. 필요한 시점에는 전체를 분해함으로써 그 안에 포함된 부분들을 새로운 전체로 다룰 수 있다. 전체와 부분 간의 일관된 계층 구조는 재귀적인 설계를 가능하게 한다.
집합은 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다. 집합과 분해는 한 번에 다뤄야 하는 요소의 수를 감소시킴으로써 인지 과부하를 방지한다.

### 합성 관계

객체와 객체 사이의 전체-부분 관계를 구현하기 위해서 합성 관계를 사용한다. **합성 관계**는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.
그에 비해 단순히 물리적인 통로가 존재하는 경우는 **연관 관계**라고 한다.
합성 관계와 연관 관계 사이의 차이가 항상 명확하지는 않지만 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다.
연관 관계로 연결된 두 객체는 생명 주기와 관련된 어떤 제약도 부과하지 않아서 독립적으로 제거될 수 있다. 따라서 합성 관계는 생명주기 측면에서 연관 관계보다 더 강하게 객체들을 결합한다.

### 패키지

합성 관계를 이용한 객체 그룹을 단순화하더라도 클래스 수가 많아지면 클래스 간의 의존성 관리는 어렵다. 이 구조를 단순화하기 위해서 서로 관련성이 높은 클래스 집합을 논리적인 단위로 통합해야 한다. 이처럼 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 **패키지(package)** 또는 **모듈(module)** 이라고 한다.

패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다. 또한 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다.

합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.

### ✍🏻 Writer

|                                                                   이승철                                                                   |
| :----------------------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/83414134/202398444-a93994ce-6299-44a1-9c05-695abc618d1e.png" width="150" height="150"> |
|                                                   [Seung72](https://github.com/Seung72)                                                    |
